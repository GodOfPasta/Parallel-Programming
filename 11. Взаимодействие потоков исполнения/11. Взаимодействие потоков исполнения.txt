~~~~~~~~~~~~~~~~~~ВЗАИМОДЕЙСТВИЕ ПОТОКОВ ИСПОЛНЕНИЯ~~~~~~~~~~~~~~~

 Многопоточость заменяет циклы ожидания событий благодаря 
 разделению задачи на дискретные единицы. 
 Так же потоки исполнения исключают \опрос\
	| Опрос - цикл, организуемый для переодической проверки
	|  	  некоторого условия. Когда условие истинно,
	|	  выполняется действие.
 Чтобы избежать опроса в Java есть функции:
	wait() - вынуждает вызывающий поток исполнения уступить 
		 монитор и перейти в ожидание до тех пор, пока
		 какой-нибудь другой поток не вызовет метод
		 notify().
	notify() - возобновляет исполнение потока, из которого был
		   вызван метод wait() для того же самого объекта.
	notifyAll() - возобновляет исполнение всех потоков, 		      из которых был ввызван метод wait() для того
		      же самого объекта. Одному из этих объектов 		      предоставляется доступ.

 Рассмотрим задачу организации очереди, уогда некие данные  поставляются в одном потоке исполнения и потребляются в другом.  При этом поставщик должен ожидать завершения работы потребителя,  прежде чем сформировать новые данные.

I. Неправильная реализация (Example 11.1)

  Программа состоит из четырех классов:
	Queue - синхронизируемая очередь
	Producer - поточный объект, создающий эл-ы очереди
	Consumer - поточный объект, принимающий эл-ы очереди
	PC - класс, в котором создаются объекты классов Queue, 	   	     Producer, Consumer
  В данном примере (запускать его большого смысла нет, т.к. ЦП     выполняет программу слишком быстро) результат может быть,       например, таким:
    Отправлено: 1
    Получено: 1
    Получено: 1
    Получено: 1
    Получено: 1
    Получено: 1
    Отправлено: 2
    Отправлено: 3
    Отправлено: 4
    Отправлено: 5
    Отправлено: 6
    Отправлено: 7
    Получено: 7

  Это связано с тем, что, ни смотря на то что методы put() и get()   синхронизированы в классе Queue, ничто не остановит переполнение   потребителя данными от поставщика, как и ничто не помешает     потребителю дважды извлечь один и тот же эл-т из очереди.

  Так, после того, как поставщик отправит значение 1, запускается   потребитель, который получает эжто значение пять раз, потом   поставщик передает значения от 2 до 7, не давая возможности   потребителю получить их.

  Это происходит потому что synchronized просто не дает методам   put() и get() выполняться одновременно, а вот очередь выполнения   все равно "случайна".

II. Правильная реализация (Example11.2)

  Здесь был изменен класс Queue: в него добавлен флаг valueSet,     который показывает, что значение n было изменено.

  В метод get() добавилась проверка на заполненность n, т.е. если    значение n не было изменено методом set(), метод переходит в     режим ожидания, иначе он уведомляет о получении очередью эл-а n,   меняет флаг на false и возобновляет другой метод (метод set()),    если тот был остановлен.

  Метод set() изменен аналогично.

~~~~~~~~~~~~~~~~~~~~~~~~ВЗАИМНАЯ БЛОКИРОВКА~~~~~~~~~~~~~~~~~~~~~~~

Взаимная блокировка - ситуация, когда потки исполнения имеют цикличесукую зависимость от пары синхронизированных объктов.
Например, один поток исполнения входит в монитор объекта Х, а другой - в монитор объекта Y. Если поток исполнения в объекте Х пытается вызвать любой синхронизированный метод для объекта Y, он будет блокирован. Если при этом объект Y попытается вызвать синхронизированный метод из Х, то он будет ждать вечно, так как этот объект ожидает снятие блокировки Y (Pic11.1)

ВБ - сложная для отладки ошибка, т.к.:
  1. ВБ возникает очень редко, когда исполнение двух потоков точно      совпадает по времени.
  2. ВБ может возникуть, если в ней участвует >2 потоков и >2      синхронизированных объектов (случай выше самый простой)

Рассмотрим ВБ на практике (Example11.3)

Создается два класса, A и B, с методами foo() и bar() соотв., которые приостанавливаются при попытке вызвать метод из другого класса.
Сначала в главном классе Deadlock получаются экземпляры классов А и В, а затем запускается второй поток исполнения, в котором устанавливается состояние взаимной блокировки.

Результат выполнения программы:
  Главный поток вошел в метод А.foo()
  Соперничающий поток вошел в метод А.foo()
  Главный поток пытается вызвать метод B.last()
  Соперничающий поток пытается вызвать метод B.last()

Итог - если многопоточная программа зависла нужно проверить возможность БП.







