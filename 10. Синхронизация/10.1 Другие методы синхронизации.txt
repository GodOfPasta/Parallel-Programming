 Проблема программы Example10.1 состоит в том, что, несмотря на порядок 
вызова потоков, нельзя предскзать, какой поток войдет в synchronized
первым, т.е. настраивается /доступ/, а не /порядок/

Для синхронизации используются классы 
	Semaphore
	CountDownLatch
	CyclicBarrier
	Lock 

I. Semaphore - служит для ограничения количества потоков при работе с 
ресурсами. Доступ ограничивается с помощью счётчика:
  Сначала он больше нуля и доступ открыт
  Если доступ открыт, то поток может воздействовать на объект, при этом
 счетчик уменьшается
  Если счётчик равен 0, то доступ закрывается, пока другой поток не 
 освободит ресурс

Для получения доступа используется метод acquire(), 
для освобождения - release()
(Cм. Example10.2)

 Здесь с помощью метода acquire() семафор могут захватить только два 
потока, остальные встают в очередь

Результат работы программы:
	Thread 1 before semaphore
	Thread 4 before semaphore
	Thread 3 before semaphore
	Thread 0 before semaphore
	Thread 2 before semaphore
	Thread 4 got access to a resource
	Thread 3 got access to a resource
	Thread 3 release a resource
	Thread 4 release a resource
	Thread 1 got access to a resource
	Thread 2 got access to a resource
	Thread 1 release a resource	
	Thread 2 release a resource
	Thread 0 got access to a resource
	Thread 0 release a resource

II. CountDownLatch - позволяет потоку ожидать до тех пор, пока не 
завершится определенное кол-во операций, выполняющихся в других потоках,
в режим ожидания входят с помощью  метода await().
 Кол-во требуемых операций задается при создании объекта, после чего
уменьшается при вызове метода countDown().
 Когда счетчик доходит до 0, ожидающий поток разблокируется
(См. Example10.3)

 Здесь CDL создан в потоке main, при этом счётчик умемньшается при 
выполнении потока, => главный поток ждет, пока все потоки выполнятся, 
а уже потом завершается

Результат работы программы:
	Start
	Thread #4 is ready
	Thread #2 is ready
	Thread #5 is ready
	Thread #3 is ready
	Thread #0 is ready
	Thread #1 is ready
	Work is done

III. CyclicBarrier - используется для синхронизации заданного кол-ва 
потоков в одной точке. 
 При вызове метода await() поток блокируется. Когда заданное кол-во
потоков разблокировалось, с них одновременно снимается блокировка
(См. Example10.4)

 Здесь, не смотря на то, что какие-то потоки закончили подготовку 
раньше, а какие-то позже, стартовали они в одно и то же время, 
так как блокировка снимается одновременно.

Результат работы программы:
	Thread #0 is preparing
	Thread #2 is preparing
	Thread #1 is preparing
	Thread #0 is ready
	Thread #1 is ready
	Thread #2 is ready
	Thread #0 is started
	Thread #1 is started
	Thread #2 is started

IV. Lock - интерфейс, который представляет собой продвинутый 
механизм синхронизации потоков. Т.к. Lock - это интерфейс, для
работы с ним необходимо создать объект одной из его реализаций:
	Lock.lock = new ReentrantLock();
	lock.lock();
	lock.unlock();
 Сначала создается объект типа Lock, после у этого объекта вызывается 
метод lock() и он захватывается. Попытка другого потока вызвать у этого 
же объекта метод lock() приведет к блокировке этого потока, пока поток 
удерживающий объект типа Lock не освободит его с помощью метода unlock(). 
 После вызова метода unlock() объект типа Lock освобождается, и другие 
потоки могут его захватить
 Основные отлдичия между Lock и синхронизированными блоками:
   Синхронизированные блоки не гарантируют сохранность порядка обращения 
  потоков к критической секции;
   Выйти из синхронизированного блока по времени ожидания(timeout) не 
  получится;
   Синхронизированные блоки должны полностью содержаться в одном методе, в 
  то время как Lock может быть захвачен в одном методе, а освобожден в 
  другом.


















